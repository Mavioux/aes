#ifndef _AES_HPP_
#define _AES_HPP_

#include <stdint.h>
#include <stdlib.h> 
#include <cstring>
// #include <map>

#include <stdio.h>

enum AES_SIZE
{
    AES_128,
    AES_192,
    AES_256
};

// std::map<std::int, int> sbox { 
//     {"CPU", 10}, 
//     {"GPU", 15}, 
//     {"RAM", 20}, 
// };

const int sbox[16][16] = {
    {0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b,
     0xfe, 0xd7, 0xab, 0x76},
    {0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf,
     0x9c, 0xa4, 0x72, 0xc0},
    {0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1,
     0x71, 0xd8, 0x31, 0x15},
    {0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2,
     0xeb, 0x27, 0xb2, 0x75},
    {0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3,
     0x29, 0xe3, 0x2f, 0x84},
    {0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39,
     0x4a, 0x4c, 0x58, 0xcf},
    {0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f,
     0x50, 0x3c, 0x9f, 0xa8},
    {0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21,
     0x10, 0xff, 0xf3, 0xd2},
    {0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d,
     0x64, 0x5d, 0x19, 0x73},
    {0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14,
     0xde, 0x5e, 0x0b, 0xdb},
    {0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62,
     0x91, 0x95, 0xe4, 0x79},
    {0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea,
     0x65, 0x7a, 0xae, 0x08},
    {0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f,
     0x4b, 0xbd, 0x8b, 0x8a},
    {0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9,
     0x86, 0xc1, 0x1d, 0x9e},
    {0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9,
     0xce, 0x55, 0x28, 0xdf},
    {0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f,
     0xb0, 0x54, 0xbb, 0x16}};

const int inv_sbox[16][16] = {
    {0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e,
     0x81, 0xf3, 0xd7, 0xfb},
    {0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44,
     0xc4, 0xde, 0xe9, 0xcb},
    {0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b,
     0x42, 0xfa, 0xc3, 0x4e},
    {0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49,
     0x6d, 0x8b, 0xd1, 0x25},
    {0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc,
     0x5d, 0x65, 0xb6, 0x92},
    {0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57,
     0xa7, 0x8d, 0x9d, 0x84},
    {0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05,
     0xb8, 0xb3, 0x45, 0x06},
    {0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03,
     0x01, 0x13, 0x8a, 0x6b},
    {0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce,
     0xf0, 0xb4, 0xe6, 0x73},
    {0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8,
     0x1c, 0x75, 0xdf, 0x6e},
    {0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e,
     0xaa, 0x18, 0xbe, 0x1b},
    {0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe,
     0x78, 0xcd, 0x5a, 0xf4},
    {0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59,
     0x27, 0x80, 0xec, 0x5f},
    {0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f,
     0x93, 0xc9, 0x9c, 0xef},
    {0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c,
     0x83, 0x53, 0x99, 0x61},
    {0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63,
     0x55, 0x21, 0x0c, 0x7d}};

const int galois_mul[16] = {
    2, 3, 1, 1,
    1, 2, 3, 1,
    1, 1, 2, 3,
    3, 1, 1, 2
};

const int RCON[10][4] = {{0x01, 0x00, 0x00, 0x00},
                         {0x02, 0x00, 0x00, 0x00},
                         {0x04, 0x00, 0x00, 0x00},
                         {0x08, 0x00, 0x00, 0x00},
                         {0x10, 0x00, 0x00, 0x00}, 
                         {0x20, 0x00, 0x00, 0x00}, 
                         {0x40, 0x00, 0x00, 0x00}, 
                         {0x80, 0x00, 0x00, 0x00}, 
                         {0x1b, 0x00, 0x00, 0x00}, 
                         {0x36, 0x00, 0x00, 0x00}};

class AES {   
    int plaintext[16];
    int key[16];
    uint8_t plaintext_len;
    uint8_t key_len;
    uint8_t number_of_rounds;

    public:
        AES(int plaintext[], 
            int key[], 
            AES_SIZE aes_size            
        ) {
            switch (aes_size)
            {
            case AES_128:
                this->plaintext_len = 16;
                this->key_len = 16;
                this->number_of_rounds = 10;
                std::memcpy(this->plaintext, plaintext, plaintext_len * sizeof(int));
                std::memcpy(this->key, key, key_len * sizeof(int));

                break;
            
            default:
                // or throw exception
                this->plaintext_len = 16;
                this->key_len = 16;
                this->number_of_rounds = 10;
                break;
            }     
        }

        void Encrypt(int ciphertext[]) {
            int state[16];
            int key[16];
            int temp_keys[11][16];
            int keys[11][16];

            KeyExpansion(this->key, temp_keys); 

            for(uint8_t i = 0; i < 4; i++){
                for(uint8_t j = 0; j < 4; j++){
                    state[4 * i + j] = this->plaintext[4 * j + i];
                } 
            }

            for(uint8_t k = 0; k < 11; k++) {
                for(uint8_t i = 0; i < 4; i++){
                    for(uint8_t j = 0; j < 4; j++){
                        keys[k][4 * i + j] = temp_keys[k][4 * j + i];
                    } 
                }
            }
            AddRoundKey(state, keys[0]);
            for(uint8_t i = 1; i < this->number_of_rounds; i++) {
                SubBytes(state);
                ShiftRows(state);
                MixColumns(state);
                AddRoundKey(state, keys[i]);
            }
            SubBytes(state);
            ShiftRows(state);
            AddRoundKey(state, keys[10]);
            
            for(uint8_t i = 0; i < 4; i++){
                for(uint8_t j = 0; j < 4; j++){
                    ciphertext[4 * i + j] = state[4 * j + i];
                } 
            }
        }

        void KeyExpansion(int key[16], int keys[11][16]) {
            int N = 4;

            // w0-w3 set to initial key
            int w[44][4];
            memcpy(&w[0], &key[0], 4 * sizeof(int));
            memcpy(&w[1], &key[4], 4 * sizeof(int));
            memcpy(&w[2], &key[8], 4 * sizeof(int));
            memcpy(&w[3], &key[12], 4 * sizeof(int));

            for(uint8_t j = 0; j < 4; j++) {
                memcpy(&keys[0][j * 4], &w[j][0], 4 * sizeof(int));
            }   

            //w4-w43
            for(int i = 4; i < 44; i++) {
                if(i % N == 0) {
                    int w1[4];
                    memcpy(w1, &w[i - N], 4 * sizeof(int));
                    int w2[4];
                    memcpy(w2, &w[i - 1], 4 * sizeof(int));
                    RotWord(w2);
                    SubWord(w2);

                    for(uint8_t j = 0; j < 4; j++) {
                        w[i][j] = w1[j] ^ w2[j] ^ RCON[i/N-1][j];
                    }
                }
                else {
                    int w1[4];
                    memcpy(w1, &w[i - N], 4 * sizeof(int));
                    int w2[4];
                    memcpy(w2, &w[i - 1], 4 * sizeof(int));

                    for(uint8_t j = 0; j < 4; j++) {
                        w[i][j] = w1[j] ^ w2[j];
                    }
                }

                memcpy(&keys[i/4][(i % 4) * 4], &w[i][0], 4 * sizeof(int));  
            }
        }

        void RotWord(int w[4]) {
            int temp = w[0];
            w[0] = w[1];
            w[1] = w[2];
            w[2] = w[3];  
            w[3] = temp;         
        }

        void SubWord(int w[4]) {
            for(uint8_t i = 0; i < 4; i++) {
                w[i] = sbox[w[i] / 16][w[i] % 16];
            }
        }

        void AddRoundKey(int state[], int key[]) {
            int temp[this->plaintext_len];
            for(uint8_t i = 0; i < this->plaintext_len; i++) {
                temp[i] = state[i] ^ key[i];
            }
            std::memcpy(state, temp, this->plaintext_len * sizeof(int));
        }

        void SubBytes(int state[]) {
            for(uint8_t i = 0; i < 16; i++) {
                state[i] = sbox[state[i] / 16][state[i] % 16];
            }
        }

        void ShiftRows(int state[]) {
            int temp[16];
            for(uint8_t i = 0; i < 4; i++) {
                temp[i] = state[i];
            }
            temp[4] = state[5];
            temp[5] = state[6];
            temp[6] = state[7];
            temp[7] = state[4];
            temp[8] = state[10];
            temp[9] = state[11];
            temp[10] = state[8];
            temp[11] = state[9];
            temp[12] = state[15];
            temp[13] = state[12];
            temp[14] = state[13];
            temp[15] = state[14];

            memcpy(state, temp, this->plaintext_len * sizeof(int));
        }

        void MixColumns(int state[]){
            int row[4];
            for(uint8_t i = 0; i < 4; i++) {
                for(uint8_t j = 0; j < 4; j++) {
                    row[j] = state[4 * j + i];
                }
                MixColumn(row);
                for(uint8_t j = 0; j < 4; j++) {
                    if(row[j] > 255) {
                        row[j] -= 256; 
                    }
                    state[4 * j + i] = row[j];
                }
            }
        }

        void MixColumn(int r[]) {
            int a[4];
            int b[4];
            int c;
            int h;

            for (c = 0; c < 4; c++) {
                a[c] = r[c];
                /* h is 0xff if the high bit of r[c] is set, 0 otherwise */
                h = (r[c] >> 7) & 1; /* arithmetic right shift, thus shifting in either zeros or ones */
                b[c] = r[c] << 1; /* implicitly removes high bit because b[c] is an 8-bit char, so we xor by 0x1b and not 0x11b in the next line */
                b[c] ^= h * 0x1B; /* Rijndael's Galois field */
            }
            r[0] = b[0] ^ a[3] ^ a[2] ^ b[1] ^ a[1]; /* 2 * a0 + a3 + a2 + 3 * a1 */
            r[1] = b[1] ^ a[0] ^ a[3] ^ b[2] ^ a[2]; /* 2 * a1 + a0 + a3 + 3 * a2 */
            r[2] = b[2] ^ a[1] ^ a[0] ^ b[3] ^ a[3]; /* 2 * a2 + a1 + a0 + 3 * a3 */
            r[3] = b[3] ^ a[2] ^ a[1] ^ b[0] ^ a[0]; /* 2 * a3 + a2 + a1 + 3 * a0 */
        }
    
};

#endif

// TODO Implement hashmap in SubBytes step